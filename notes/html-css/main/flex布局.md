# flex布局

## flex-組成

設置方式:給父元素(外盒)設置**display:flex**,子元素可以自動擠壓或拉伸

![image.png](flex%E5%B8%83%E5%B1%80/image.png)

預設情況下，主軸(main axis)是水平(x軸)方向

## flex-布局

## 創建flex容器 display: flex

## 主軸對齊方式 justify-content/行對齊方式 align-content(有wrap時生效)

flex-start 預設 從盒子起點依次排列

flex-end 從盒子終點依次排列

center 沿主軸居中排列

space-between 沿主軸均勻排列，空白間距分布盒子之間 視覺效果:彈性”盒子之間”的間距相等

space-around  沿主軸均勻排列，空白間距分布盒子兩側  視覺效果:彈性盒子之間的間距是盒子兩端間距的兩倍

space-evenly 沿主軸均勻排列，盒子與容器之間間距相等   視覺效果:彈性盒子與外盒子個個間距都相等

## 側軸對齊方式/單個盒子側軸對齊 align-items/align-self

**側軸:預設是y軸 跟主軸垂直**

### align-items:

當前"彈性容器”內的所有盒子的側軸對齊方式(給彈性容器元素-通常是父級)

### align-self:

單獨控制其中一個”彈性盒子”的側軸對其方式(給彈性盒子元素-通常是子級)

stretch:盒子沿著軸線被拉伸直至鋪滿容器(彈性盒子沒有設置”側面軸”尺寸才可拉伸)

center:盒子沿著側軸居中排列

## 

## 修改主軸方向:flex-direction

row:水平 從左到右邊(預設)

column:垂直方向 從上到下

## 複合屬性:flex

控制彈性盒子的主軸方向的尺寸

flex:數字 占用父級剩餘尺寸的份數

`flex` 屬性是一個簡寫 (shorthand) 屬性，它實際上合併了三個屬性：

1. `flex-grow` **允許元素放大**。如果容器有剩餘空間，這個元素將會按比例佔據這部分空間

2. `flex-shrink`**允許元素縮小**。如果容器空間不足，這個元素會按比例縮小

3. `flex-basis`
設定元素的 **初始尺寸**
這表示在計算剩餘空間之前，元素被視為沒有寬度/高度，所有的空間都被視為「剩餘空間」可以被 `flex-grow` 分配。

**`flex: 0 0 XXXpx` 的含義**

當你寫 `flex: 0 0 XXXpx` 時，它等同於：
• `flex-grow: 0`
• `flex-shrink: 0`
• `flex-basis: XXXpx`

**子屬性數值含義**

`flex-grow`**0不允許元素放大**。即使容器有剩餘空間，這個元素也不會變大來佔據它。

`flex-shrink`**0不允許元素縮小**。即使容器空間不足，這個元素也會保持其 

`flex-basis` 設定的尺寸（除非這是絕對不可能的）。`flex-basisXXX`**px**設定元素的 **初始尺寸** 為 **200px**。這是元素在分配剩餘空間之前的理想尺寸。

**`flex` 三個子屬性的預設值**

Flex 容器中的所有子項目，如果沒有明確設定 `flex` 屬性，它們會使用以下預設值：

`flex-grow`**0不放大**。子項目即使有剩餘空間也不會變大。

`flex-shrink`**1允許縮小**。子項目在空間不足時會按比例縮小。

`flex-basis`**auto自動尺寸**。子項目的初始尺寸由其內容 (`content`) 或明確設定的 `width`/`height` 決定。

## 彈性盒子換行:flex-wrap

wrap:換行

nowrap:不換行(預設)

## 彈性盒子間距:gap/row-gap

## 彈性盒子補充

## 彈性盒子 (Flexbox) 的基本特性

Flexbox 是一種一維的佈局模型，它解決了傳統 CSS 在處理元素對齊、分佈空間和排序上的許多困難。它區分為兩個主要角色：

1. **Flex 容器 (Flex Container)**：設定了 `display: flex;` 或 `display: inline-flex;` 的父元素。
2. **Flex 項目 (Flex Item)**：Flex 容器的**直接子元素**。

---

## Flexbox 的「繼承性」：極為有限

關於繼承性，您需要記住一個核心原則：**Flexbox 佈局屬性本身是不會繼承的。**

| 屬性類別 | 繼承性 | 說明 |
| --- | --- | --- |
| **Flex 佈局屬性** | **不繼承** | 作用於容器的屬性（如 `display: flex;`、`align-items`、`justify-content`）或作用於項目的屬性（如 `flex-grow`、`align-self`）**不會** 傳遞給 Flex 項目的子元素（孫子元素）。 |
| **標準 CSS 屬性** | **會繼承** | 標準的 CSS 屬性（如 `font-size`、`color`、`line-height`） **會** 繼續按照正常的 CSS 規則繼承。 |

匯出到試算表

### 繼承性範例：

如果您有 `<ul>` 設定了 `display: flex;`，那麼：

- `<li>` 是 Flex 項目，會受到 `ul` 的 `justify-content` 影響。
- `<a>` 在 `<li>` 內部，它**不是** Flex 項目，因此它不會受到 `ul` 的 Flex 佈局屬性影響。

**這就是為什麼您必須手動對 `a` 標籤設定 `display: block;` 或 `display: flex;`，才能讓它具備塊級或 Flex 容器的特性。**

---

## Flexbox 的「優先度」：高於傳統佈局

Flexbox 屬性在佈局中具有非常高的優先權，它們經常會覆蓋傳統 CSS 屬性，這是 Flexbox 容易產生誤解但非常強大的地方。

### 1. 垂直對齊優先度 (Align-Items vs. Margin)

- **`align-items: center;` 優先於垂直 `margin: auto;`**：
當一個 Flex 項目被明確設定了 `align-items: center;` 或 `align-self: center;` 時，**垂直軸上的自動邊距 (`margin-top: auto; margin-bottom: auto;`) 會失效。** 兩者都會嘗試置中，但 Flex 屬性會接管。
    - **水平軸** 則相反：Flex 項目上的 `margin-left: auto;` 和 `margin-right: auto;` **依然有效**，且會佔據所有可用空間，通常用於推開元素到邊緣。

### 2. 尺寸優先度 (Stretch vs. Height/Width)

- **`align-items: stretch;`（預設值）優先於 `height` / `width` / `min-height` / `min-width`**：
Flex 容器預設會將 Flex 項目沿交叉軸（例如垂直軸）拉伸，以填滿容器的空間。
    - **如果項目沒有設定 `height`**，它會自動拉伸到容器高度。
    - **如果項目設定了固定的 `height` 或 `max-height`**，則該尺寸會優先於 `stretch`。這解釋了為什麼您對 `a` 標籤設定 `line-height: 18px` 後，`a` 的行盒會被 24px 的空間拉伸，但一旦設定 `display: inline-block` 或 `block`（讓 `a` 變成一個有明確尺寸的實體），它就能抵抗拉伸。

### 3. `display` 轉換的優先度

- **Flex 項目上的 `display` 屬性會被忽略或重寫：**
Flex 容器的**直接子元素**（Flex 項目）會自動成為 **塊級上下文 (Block Context)**。
    - 即使您對 `li` 設定 `display: inline;` 或 `display: inline-block;`，Flexbox 也會將其視為一個 Flex 項目，並**忽略**這些傳統的 `display` 設定。

總結來說，當涉及到佈局控制時，**Flexbox 的專有屬性具有最高的控制優先權。** 要解決置中和對齊問題，您通常需要先了解 Flex 容器正在對 Flex 項目做什麼（例如預設拉伸），然後用特定的 Flex 屬性 (`align-self` 或 `height`) 來覆蓋它。

## 彈性盒子-父子級絕對置中

這是對 Flexbox 概念非常深入的提問！當您在 **父級 `li`** 和 **子級 `a`** 上分別設置 `display: flex` 時，它們的 **角色** 和 **作用範圍** 會發生根本性的區別。

您必須區分 **「Flex 項目」** 和 **「Flex 容器」** 的不同，這直接決定了誰可以控制誰。

---

## 父級 (`li`) vs. 子級 (`a`) 設置 Flex 的區別

| 設置 Flex 的元素 | 元素角色 | 控制範圍 | 主要功能 |
| --- | --- | --- | --- |
| **父級 `li`** | **Flex 容器** | 控制 `li` 的 **直接子元素**（即 `a` 標籤）。 | **佈局 `a` 標籤**：控制 `a` 的水平排列、垂直對齊和佔用空間。 |
| **子級 `a`** | **Flex 容器** | 控制 `a` 標籤 **內部的內容**（例如圖片和文字）。 | **內容置中**：控制圖片和文字的水平和垂直對齊。 |

匯出到試算表

### 1. 將 `li` 設為 Flex 容器 (父級控制)

當您對 **`li`** 設置 `display: flex;` 時：

- **`li`** 變成了 **Flex 容器**。
- **`a`** 變成了 **Flex 項目**。

**目的：** 是為了控制 `a` 標籤在 `li` 空間中的**位置**和**尺寸**。

- *範例：* 您可以用 `li` 上的 `justify-content` 決定 `a` 是靠左、置中還是靠右。
- *您的導航列場景：* 這通常是多餘的，因為 `li` 內只有一個 `a`，所以 `a` 會自動填滿 `li` 的空間。

### 2. 將 `a` 設為 Flex 容器 (子級控制/內容置中)

當您對 **`a`** 設置 `display: flex;` 時：

- **`a`** 變成了 **Flex 容器**。
- **`a` 內部的圖片和文字** 變成了 **Flex 項目**。

**目的：** 是為了控制 **`a` 標籤內的內容**（文字、圖示）如何對齊。

- *範例：* 您可以用 `a` 上的 `align-items: center;` 來確保圖示和文字在 60px 高的 `a` 標籤內**垂直精準置中**。
- *解決行高誤差：* 這是我們解決 **行高誤差** 的最佳方式，因為 Flexbox 優先於傳統的行內元素對齊（`line-height` 和 `vertical-align`）。

---

## 總結：最穩定的導航列切版策略

在 `<li>` 包裹 `<a>` 的導航列結構中，最穩定的方法是 **同時利用 Flexbox 的兩層控制**：

1. **UL 層 (最外層)**：設為 `display: flex`，目的是讓 `li` 項目 **水平排列**。
2. **A 層 (最內層)**：設為 `display: flex`，目的是讓 `a` 標籤內的 **內容精準置中**。

如果您只需要解決單純的行高誤差（單一文字），只需確保 `a` 具備 `display: block` 或 `display: inline-block`，並使用 `line-height` 等於 `height` 的技巧即可。但只要您有 **圖片、圖示或多個行內元素** 組合，那麼 **對 `a` 設置 `display: flex`** 是實現像素級精確置中的不二法門。

## Flexbox 垂直置中邏輯的精確修正

| 您的理解 | 正確的 Flexbox 行為 |
| --- | --- |
| **「原本設定的 `align-items: center` 是置中了包裹著文字的 `a`。」** | **正確。** `a` 是 Flex 項目，`align-items: center` 將它在 60px 容器內居中。 |
| **「因為 `a` 這個元素的高度跟文字一樣，所以 20px 的高度可以置中於 60px 的盒子裡。」** | **正確。** 假設 a 高 20px，Flexbox 會將這 20px 的 **實體盒子** 放在 60px 空間的中心。 |
| **「當我把 `a` 這個盒子定義成 60px，他填滿了外盒，文字在裡面則會靠上對齊。」** | **完全正確。** 60px 的 `a` 填滿 60px 的空間，**外部置中邏輯失效**。文字（內容）在 60px 的 `a` 裡面，**預設是靠上對齊**。 |
| **「起初 20px 盒子內的文字其實也不是真正意義上的置中，只是因為他填滿了盒子而已，所以可以和盒子一起被致中。」** | **錯誤/不精確。** 這是最需要修正的部分。 20px 的文字**在 20px 的 a 盒子內**，它一開始就是被置中的！ |

匯出到試算表

---

## 總結和關鍵區別：兩層置中

要徹底理解，您需要區分 **「內容置中」** 和 **「盒子置中」**：

### 階段一：a 標籤的預設狀態 ( 20px 高)

1. **內容置中（內層）：** `a` 標籤的文字（約 18px）被它自身的 `line-height` 和 `font-size` 均勻包裹，形成一個約 20px 高的 **行盒（Line Box）**。在這個 20px 內，文字是垂直居中的。
    - **結論：** **文字在 `a` 內是置中的。**
2. **盒子置中（外層）：** Flex 容器 (`.hd`) 上的 `align-items: center` 將這個 20px 高的 `a` 盒子，放在 60px 容器的中心。
    - **結論：** **`a` 盒子在 `.hd` 內是置中的。**

**因此，文字從頭到尾都是置中的！** a 盒子作為一個完整的 20px 實體，帶著它內部已經置中的文字一起被 Flexbox 置中。

### 階段二：`a` 標籤被強制 60px 高

1. **內容置中（內層）：** 60px 高的 `a` 盒子內部，文字（約 18px）失去了它原始 20px 行盒的保護，**預設會靠 60px 盒子的頂部對齊。**
2. **盒子置中（外層）：** 60px 高的 `a` 盒子填滿了 60px 容器，**不需要** 居中。

**修正：** 為了讓文字置中，您需要做的是 **重新開啟內層的「內容置中」機制**，例如：

- 在 `a` 上設定 `line-height: 60px;`。
- 或將 `a` 設置為 `display: flex;` 並使用 `align-items: center;`。

這是 Flexbox 最常見的「陷阱」之一：**Flexbox 解決的是盒子與盒子之間的關係，但不一定解決內容與盒子之間的關係。**